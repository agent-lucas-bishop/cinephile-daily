import type { VercelRequest, VercelResponse } from '@vercel/node';
import { readFileSync } from 'fs';
import { join } from 'path';

const TMDB_KEY = process.env.TMDB_API_KEY!;
const TMDB = 'https://api.themoviedb.org/3';
const IMG = 'https://image.tmdb.org/t/p/w185';
const POSTER = 'https://image.tmdb.org/t/p/w500';

const GENRES: Record<number, string> = {
  28: 'Action', 12: 'Adventure', 16: 'Animation', 35: 'Comedy', 80: 'Crime',
  99: 'Documentary', 18: 'Drama', 10751: 'Family', 14: 'Fantasy', 36: 'History',
  27: 'Horror', 10402: 'Music', 9648: 'Mystery', 10749: 'Romance', 878: 'Science Fiction',
  10770: 'TV Movie', 53: 'Thriller', 10752: 'War', 37: 'Western',
};

const DAILY_GENRE_IDS = [28, 12, 16, 35, 80, 18, 10751, 14, 36, 27, 10402, 9648, 10749, 878, 53, 10752, 37];

// Load static movie pools (generated by scripts/generate-pool.ts)
let moviePools: Record<string, number[]> = {};
try {
  const raw = readFileSync(join(__dirname, 'movie-pools.json'), 'utf-8');
  moviePools = JSON.parse(raw).pools;
} catch {
  console.error('Failed to load movie-pools.json — falling back to empty pools');
}

// Seeded PRNG (mulberry32)
function mulberry32(seed: number) {
  return function () {
    let t = (seed += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function dateSeed(dateStr: string): number {
  let hash = 0;
  for (let i = 0; i < dateStr.length; i++) {
    hash = ((hash << 5) - hash) + dateStr.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash);
}

async function fetchJson(url: string) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`TMDB ${res.status}: ${url}`);
  return res.json();
}

function shuffle<T>(arr: T[], rng: () => number): T[] {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/**
 * Pick 3 movie IDs from the static pool using seeded RNG.
 * Fetches release dates to ensure decade diversity.
 */
function pickMovieIds(pool: number[], rng: () => number, count: number): number[] {
  if (pool.length <= count) return pool.slice(0, count);
  const shuffled = shuffle([...pool], rng);
  return shuffled.slice(0, count);
}

// In-memory cache survives across warm invocations
let cachedDate = '';
let cachedResult: any = null;

export default async function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const now = new Date();
    const dateStr = `${now.getUTCFullYear()}-${String(now.getUTCMonth() + 1).padStart(2, '0')}-${String(now.getUTCDate()).padStart(2, '0')}`;

    if (cachedDate === dateStr && cachedResult) {
      const endOfDay = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 23, 59, 59));
      const maxAge = Math.max(60, Math.floor((endOfDay.getTime() - now.getTime()) / 1000));
      res.setHeader('Cache-Control', `public, s-maxage=${maxAge}, stale-while-revalidate=3600`);
      return res.status(200).json(cachedResult);
    }

    const endOfDay = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 23, 59, 59));
    const maxAge = Math.max(60, Math.floor((endOfDay.getTime() - now.getTime()) / 1000));
    res.setHeader('Cache-Control', `public, s-maxage=${maxAge}, stale-while-revalidate=3600`);

    const seed = dateSeed(dateStr);
    const rng = mulberry32(seed);

    // Pick today's genre
    const genreIdx = Math.floor(rng() * DAILY_GENRE_IDS.length);
    const genreId = DAILY_GENRE_IDS[genreIdx];
    const genre = GENRES[genreId];

    // Get pool from static data
    const pool = moviePools[String(genreId)] ?? [];
    if (pool.length < 3) {
      return res.status(500).json({ error: `Genre pool too small for ${genre}` });
    }

    // Pick 3 movie IDs deterministically
    const movieIds = pickMovieIds(pool, rng, 3);

    // Fetch full details (these don't change — same movie ID always returns same movie)
    const movies = await Promise.all(movieIds.map(async (movieId) => {
      const [details, keywords, providers] = await Promise.all([
        fetchJson(`${TMDB}/movie/${movieId}?api_key=${TMDB_KEY}&append_to_response=credits`),
        fetchJson(`${TMDB}/movie/${movieId}/keywords?api_key=${TMDB_KEY}`),
        fetchJson(`${TMDB}/movie/${movieId}/watch/providers?api_key=${TMDB_KEY}`),
      ]);

      const director = details.credits?.crew?.find((c: { job: string }) => c.job === 'Director');
      const writers = details.credits?.crew
        ?.filter((c: { department: string }) => c.department === 'Writing')
        ?.slice(0, 3)
        ?.map((c: { name: string }) => c.name) ?? [];
      const cast = (details.credits?.cast ?? []).slice(0, 6).map((c: { name: string; character: string; profile_path: string | null }) => ({
        name: c.name,
        character: c.character,
        profilePath: c.profile_path,
      }));

      return {
        id: details.id,
        title: details.title,
        year: new Date(details.release_date).getFullYear(),
        director: director?.name ?? 'Unknown',
        directorPhoto: director?.profile_path ? `${IMG}${director.profile_path}` : null,
        cast,
        writers: [...new Set(writers)],
        genre: details.genres?.[0]?.name ?? genre,
        tagline: details.tagline ?? '',
        overview: details.overview ?? '',
        plotKeywords: (keywords.keywords ?? []).slice(0, 5).map((k: { name: string }) => k.name),
        posterUrl: details.poster_path ? `${POSTER}${details.poster_path}` : '',
        rating: Math.round((details.vote_average ?? 0) * 10) / 10,
        watchProviders: (() => {
          const us = providers.results?.US;
          if (!us) return [];
          const wp: { id: number; name: string; logoUrl: string; type: 'stream' | 'rent' | 'buy' }[] = [];
          const seen = new Set<number>();
          const add = (arr: { provider_id: number; provider_name: string; logo_path: string }[] | undefined, type: 'stream' | 'rent' | 'buy') => {
            for (const p of arr ?? []) {
              if (!seen.has(p.provider_id)) {
                seen.add(p.provider_id);
                wp.push({ id: p.provider_id, name: p.provider_name, logoUrl: `https://image.tmdb.org/t/p/original${p.logo_path}`, type });
              }
            }
          };
          add(us.flatrate, 'stream');
          add(us.rent, 'rent');
          add(us.buy, 'buy');
          return wp;
        })(),
      };
    }));

    const result = { date: dateStr, movies, genre };
    cachedDate = dateStr;
    cachedResult = result;
    res.status(200).json(result);
  } catch (err) {
    console.error('daily-puzzle error:', err);
    res.status(500).json({ error: 'Failed to generate daily puzzle' });
  }
}
